{"version":3,"file":"mod-compiler.js","sourceRoot":"","sources":["../../src/plugins/mod-compiler.ts"],"names":[],"mappings":";;;;;AAAA,gDAAwB;AAGxB,sDAA6D;AAC7D,yDAAqE;AAErE;;;;GAIG;AACI,KAAK,UAAU,gBAAgB,CACpC,MAAsB,EACtB,KAAyD;IAEzD,MAAM,GAAG,+BAAY,CAAC,MAAM,CAAC,CAAC;IAC9B,OAAO,MAAM,aAAa,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAC5C,CAAC;AAND,4CAMC;AAED;;;;GAIG;AACI,KAAK,UAAU,aAAa,CACjC,MAAsB,EACtB,EAAE,WAAW,EAAE,SAAS,EAAsD;;IAE9E,KAAK,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,OAAC,MAAM,CAAC,IAAI,mCAAK,EAAgB,CAAC,EAAE;QACvF,IAAI,SAAS,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,YAAmB,CAAC,EAAE;YACzD,SAAS;SACV;QACD,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,MAAM,cAAc,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,OAAO,KAAK,WAAW,CAAC,CAAC;YACjF,IAAI,cAAc,GAAG,CAAC,CAAC,EAAE;gBACvB,2GAA2G;gBAC3G,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAC5D;YAED,MAAM,mBAAmB,GAAG,cAAI,CAAC,IAAI,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;YACjE,MAAM,WAAW,GACf,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC,+BAAmB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAEhF,KAAK,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,IAAI,OAAO,EAAE;gBACpC,MAAM,UAAU,GAAG;oBACjB,WAAW;oBACX,WAAW;oBACX,mBAAmB;oBACnB,QAAQ,EAAE,YAA2B;oBACrC,OAAO;iBACR,CAAC;gBAEF,MAAM,OAAO,GAAG,MAAO,GAAW,iCAC7B,MAAM,KACT,UAAU,EAAE,IAAI,EAChB,UAAU,IACV,CAAC;gBAEH,kDAAkD;gBAClD,MAAM,GAAG,oCAAiB,CAAC,OAAO,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;gBAC3D,8CAA8C;gBAC9C,OAAO,MAAM,CAAC,UAAU,CAAC;gBACzB,8CAA8C;gBAC9C,OAAO,MAAM,CAAC,UAAU,CAAC;aAC1B;SACF;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AA9CD,sCA8CC","sourcesContent":["import path from 'path';\n\nimport { ExportedConfig, Mod, ModConfig, ModPlatform } from '../Plugin.types';\nimport { getHackyProjectName } from '../ios/utils/Xcodeproj';\nimport { resolveModResults, withBaseMods } from './compiler-plugins';\n\n/**\n *\n * @param projectRoot\n * @param config\n */\nexport async function compileModsAsync(\n  config: ExportedConfig,\n  props: { projectRoot: string; platforms?: ModPlatform[] }\n): Promise<ExportedConfig> {\n  config = withBaseMods(config);\n  return await evalModsAsync(config, props);\n}\n\n/**\n * A generic plugin compiler.\n *\n * @param config\n */\nexport async function evalModsAsync(\n  config: ExportedConfig,\n  { projectRoot, platforms }: { projectRoot: string; platforms?: ModPlatform[] }\n): Promise<ExportedConfig> {\n  for (const [platformName, platform] of Object.entries(config.mods ?? ({} as ModConfig))) {\n    if (platforms && !platforms.includes(platformName as any)) {\n      continue;\n    }\n    const entries = Object.entries(platform);\n    if (entries.length) {\n      const dangerousIndex = entries.findIndex(([modName]) => modName === 'dangerous');\n      if (dangerousIndex > -1) {\n        // Move dangerous item to the first position if it exists, this ensures that all dangerous code runs first.\n        entries.splice(0, 0, entries.splice(dangerousIndex, 1)[0]);\n      }\n\n      const platformProjectRoot = path.join(projectRoot, platformName);\n      const projectName =\n        platformName === 'ios' ? getHackyProjectName(projectRoot, config) : undefined;\n\n      for (const [modName, mod] of entries) {\n        const modRequest = {\n          projectRoot,\n          projectName,\n          platformProjectRoot,\n          platform: platformName as ModPlatform,\n          modName,\n        };\n\n        const results = await (mod as Mod)({\n          ...config,\n          modResults: null,\n          modRequest,\n        });\n\n        // Sanity check to help locate non compliant mods.\n        config = resolveModResults(results, platformName, modName);\n        // @ts-ignore: data is added for modifications\n        delete config.modResults;\n        // @ts-ignore: info is added for modifications\n        delete config.modRequest;\n      }\n    }\n  }\n\n  return config;\n}\n"]}