"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const Xcodeproj_1 = require("../ios/utils/Xcodeproj");
const compiler_plugins_1 = require("./compiler-plugins");
/**
 *
 * @param projectRoot
 * @param config
 */
async function compileModsAsync(config, props) {
    config = compiler_plugins_1.withBaseMods(config);
    return await evalModsAsync(config, props);
}
exports.compileModsAsync = compileModsAsync;
/**
 * A generic plugin compiler.
 *
 * @param config
 */
async function evalModsAsync(config, { projectRoot, platforms }) {
    var _a;
    for (const [platformName, platform] of Object.entries((_a = config.mods) !== null && _a !== void 0 ? _a : {})) {
        if (platforms && !platforms.includes(platformName)) {
            continue;
        }
        const entries = Object.entries(platform);
        if (entries.length) {
            const dangerousIndex = entries.findIndex(([modName]) => modName === 'dangerous');
            if (dangerousIndex > -1) {
                // Move dangerous item to the first position if it exists, this ensures that all dangerous code runs first.
                entries.splice(0, 0, entries.splice(dangerousIndex, 1)[0]);
            }
            const platformProjectRoot = path_1.default.join(projectRoot, platformName);
            const projectName = platformName === 'ios' ? Xcodeproj_1.getHackyProjectName(projectRoot, config) : undefined;
            for (const [modName, mod] of entries) {
                const modRequest = {
                    projectRoot,
                    projectName,
                    platformProjectRoot,
                    platform: platformName,
                    modName,
                };
                const results = await mod(Object.assign(Object.assign({}, config), { modResults: null, modRequest }));
                // Sanity check to help locate non compliant mods.
                config = compiler_plugins_1.resolveModResults(results, platformName, modName);
                // @ts-ignore: data is added for modifications
                delete config.modResults;
                // @ts-ignore: info is added for modifications
                delete config.modRequest;
            }
        }
    }
    return config;
}
exports.evalModsAsync = evalModsAsync;
//# sourceMappingURL=mod-compiler.js.map