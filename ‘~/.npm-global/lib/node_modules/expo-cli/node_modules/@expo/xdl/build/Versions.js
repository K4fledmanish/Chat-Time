"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.versionsAsync = versionsAsync;
exports.sdkVersionsAsync = sdkVersionsAsync;
exports.setVersionsAsync = setVersionsAsync;
exports.releasedSdkVersionsAsync = releasedSdkVersionsAsync;
exports.gteSdkVersion = gteSdkVersion;
exports.lteSdkVersion = lteSdkVersion;
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
exports.newestReleasedSdkVersionAsync = newestReleasedSdkVersionAsync;
exports.newestSdkVersionAsync = newestSdkVersionAsync;
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
exports.facebookReactNativeVersionsAsync = facebookReactNativeVersionsAsync;
exports.facebookReactNativeVersionToExpoVersionAsync = facebookReactNativeVersionToExpoVersionAsync;
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;

function _getenv() {
  const data = _interopRequireDefault(require("getenv"));

  _getenv = function () {
    return data;
  };

  return data;
}

function _pickBy() {
  const data = _interopRequireDefault(require("lodash/pickBy"));

  _pickBy = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _ApiV() {
  const data = _interopRequireDefault(require("./ApiV2"));

  _ApiV = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireDefault(require("./User"));

  _User = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("./XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function _FsCache() {
  const data = require("./tools/FsCache");

  _FsCache = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function versionsAsync(options) {
  const api = new (_ApiV().default)();
  const versionCache = new (_FsCache().Cacher)(() => api.getAsync('versions/latest'), 'versions.json', 0, _path().default.join(__dirname, '../caches/versions.json')); // Clear cache when opting in to beta because things can change quickly in beta

  if (_getenv().default.boolish('EXPO_BETA', false) || (options === null || options === void 0 ? void 0 : options.skipCache)) {
    versionCache.clearAsync();
  }

  return await versionCache.getAsync();
}

async function sdkVersionsAsync() {
  const {
    sdkVersions
  } = await versionsAsync();
  return sdkVersions;
}

async function setVersionsAsync(value) {
  const user = await _User().default.getCurrentUserAsync();

  const api = _ApiV().default.clientForUser(user);

  const secret = process.env.EXPO_VERSIONS_SECRET;
  if (!secret) throw new Error('Versions.setVersionsAsync: EXPO_VERSIONS_SECRET environment variable is required');
  await api.postAsync('versions/update', {
    value: value,
    secret
  });
} // NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we only want to list out released
// versions


async function releasedSdkVersionsAsync() {
  const sdkVersions = await sdkVersionsAsync();
  return (0, _pickBy().default)(sdkVersions, (data, _sdkVersionString) => !!data.releaseNoteUrl || _getenv().default.boolish('EXPO_BETA', false) && data.beta);
}

function gteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return true;
  }

  try {
    return _semver().default.gte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new (_XDLError().default)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function lteSdkVersion(expJson, sdkVersion) {
  if (!expJson.sdkVersion) {
    return false;
  }

  if (expJson.sdkVersion === 'UNVERSIONED') {
    return false;
  }

  try {
    return _semver().default.lte(expJson.sdkVersion, sdkVersion);
  } catch (e) {
    throw new (_XDLError().default)('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
  }
}

function parseSdkVersionFromTag(tag) {
  if (tag.startsWith('sdk-')) {
    return tag.substring(4);
  }

  return tag;
} // NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we need to get the latest *released*
// version, not just the latest version.


async function newestReleasedSdkVersionAsync() {
  const betaOptInEnabled = _getenv().default.boolish('EXPO_BETA', false);

  const sdkVersions = await sdkVersionsAsync();
  let result = null;
  let highestMajorVersion = '0.0.0';

  for (const [version, data] of Object.entries(sdkVersions)) {
    const hasReleaseNotes = !!data.releaseNoteUrl;
    const isBeta = !!data.beta;

    if (_semver().default.major(version) > _semver().default.major(highestMajorVersion) && (hasReleaseNotes || isBeta && betaOptInEnabled)) {
      highestMajorVersion = version;
      result = data;
    }
  }

  return {
    version: highestMajorVersion,
    data: result
  };
}
/**
 * Be careful when using this! It can include unreleased and beta SDK versions.
 */


async function newestSdkVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();
  let result = null;
  let highestMajorVersion = '0.0.0';

  for (const [version, data] of Object.entries(sdkVersions)) {
    if (_semver().default.major(version) > _semver().default.major(highestMajorVersion)) {
      highestMajorVersion = version;
      result = data;
    }
  }

  return {
    version: highestMajorVersion,
    data: result
  };
}

async function oldestSupportedMajorVersionAsync() {
  const sdkVersions = await sdkVersionsAsync();
  const supportedVersions = (0, _pickBy().default)(sdkVersions, v => !v.isDeprecated);
  const versionNumbers = Object.keys(supportedVersions).map(version => _semver().default.major(version));
  return Math.min(...versionNumbers);
}

async function facebookReactNativeVersionsAsync() {
  const sdkVersions = await sdkVersionsAsync();
  const facebookReactNativeVersions = new Set(Object.values(sdkVersions).map(data => data.facebookReactNativeVersion).filter(version => version));
  return Array.from(facebookReactNativeVersions);
}

async function facebookReactNativeVersionToExpoVersionAsync(outerFacebookReactNativeVersion) {
  if (!_semver().default.valid(outerFacebookReactNativeVersion)) {
    throw new (_XDLError().default)('INVALID_VERSION', `${outerFacebookReactNativeVersion} is not a valid version. Must be in the form of x.y.z`);
  }

  const sdkVersions = await sdkVersionsAsync();
  let currentSdkVersion = null;

  for (const [version, {
    facebookReactNativeVersion
  }] of Object.entries(sdkVersions)) {
    if (_semver().default.major(outerFacebookReactNativeVersion) === _semver().default.major(facebookReactNativeVersion) && _semver().default.minor(outerFacebookReactNativeVersion) === _semver().default.minor(facebookReactNativeVersion) && (!currentSdkVersion || _semver().default.gt(version, currentSdkVersion))) {
      currentSdkVersion = version;
    }
  }

  return currentSdkVersion;
}

async function canTurtleBuildSdkVersion(sdkVersion, platform) {
  var _supportedVersions$pl;

  if (sdkVersion === 'UNVERSIONED') {
    return true;
  }

  if (_semver().default.valid(sdkVersion) == null) {
    throw new (_XDLError().default)('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
  }

  const supportedVersions = await getSdkVersionsSupportedByTurtle();
  const supportedVersionsForPlatform = (_supportedVersions$pl = supportedVersions[platform]) !== null && _supportedVersions$pl !== void 0 ? _supportedVersions$pl : [];
  return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}

async function getSdkVersionsSupportedByTurtle() {
  const api = new (_ApiV().default)();
  return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=__sourcemaps__/Versions.js.map
